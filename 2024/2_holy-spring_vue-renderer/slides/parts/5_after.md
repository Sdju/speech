---
layout: cover
class: text-center
---

<script setup>
import { ref, onUnmounted, getCurrentInstance, watch } from 'vue';
import {useNav} from "@slidev/client"; 
import JSConfetti from 'js-confetti';

const jsConfetti = new JSConfetti();

const instance = getCurrentInstance();
const { currentSlideNo } = useNav();

watch(currentSlideNo, (id) => {
  if (id === instance.setupState.$page) {
    jsConfetti.addConfetti({
      confettiColors: ['#ffbe0b', '#fb5607', '#ff006e', '#8338ec', '#3a86ff'],
      confettiRadius: 10,
      confettiNumber: 150,
    })
  }
});
</script>

# Поздравления!!!

<!--
Ну и мои поздравления. Мы с вами освоили фактически все методы для работы с рендерерами во Vue и теперь готовы написать свой.
-->

---
layout: cover
---

Исходники:
- `@vue/runtime-core`

<v-click>

<div mb-5 />

Как используется самим **Vue**:

</v-click>

<v-clicks at="1">

- `@vue/runtime-dom` - Рендер в DOM
- `@vue/server-renderer` - Рендерер в строку для SSR
- `@vue/runtime-test` - Самый простой для понимания!

</v-clicks>

<!--
Но для начала разберемся какже Vue использует это API сам?

Для начала исходники всего этого лежат в пакете @vue/runtime-core.

А вот используется оно в самом Vue в 3ех сценариях:
- @vue/runtime-dom где находится всем привычный рендерер для работы с DOM
- @vue/server-renderer для генерации строки на стороне сервера те SSR
- и последний пакет бонусом: @vue/runtime-test. Он не выкладывается никуда и нужен лишь для внутренних тестов работы самого Vue. Однако он самый простой для понимания и начать изучать исходники можно именно с него
-->

---
layout: cover
---

# Библиотеки 

Используют кастомные рендереры:

<v-clicks>

- **TresJS**
- **nativescript-vue**

</v-clicks>

<!--
Далее посмотрим какие есть еще библиотеки которые уже используют API для работы с рендерерами:

- TresJS. Это ThreeJS биндинги для работы со Vue.
- и nativescript-vue. Это уже библиотека позволяющая собрать Vue для работы под мобильные устройства. И там рендерер занимается как раз работой по взаимодействию с нативными элементами на телефонах вместо DOM

Ну и в целом все из наиболее известных. Поэтому я решил подглядеть, а что там у нашего голубого брата?
-->

---
layout: cover
---

<img class="absolute center w-[740px]" src="/img/loev.jpg" />
<div class="absolute top-0 left-0 w-full h-full backdrop-blur-[30px]" />
<img class="absolute center w-[740px]" src="/img/loev.jpg" />

<!--
А вот о нем уже подробнее рассказал Ярослав Лосев в своем докладе о React Reconciler-ах. Что по сути аналог Vue Custom Renderer-ов
-->

---
layout: cover
---

# Подсмотрим у React

<v-clicks>

- Рендерер для **Figma** плагинов
- Рендерер для **PDF**
- Рендерер для **Canvas**
- Рендерер в игровой движок
- Рендерер для **React**...

</v-clicks>

<!--
В нем он сделал свой рендерер для работы с Figma

Дополнительно можно найти библиотеки для вывода в
- PDF
- Camvas
- В игровой движок

Но чего у реакта точно нет, так это рендерера из react в react
-->

---
layout: cover
---

<img class="absolute center w-[740px]" src="/img/render.png" />
<div class="absolute top-0 left-0 w-full h-full backdrop-blur-[30px]" />
<img class="absolute center w-[740px]" src="/img/render.png" />

<!--
Таким образом мы можем рендерить Vue пока рендерится React
-->

---
layout: cover
---

# Зачем

<v-clicks>

- Большая независимость от фреймворка
- Рендеринг **Vue** приложений на основе **ReactNative**
- Потому что это весело!

</v-clicks>

<!--
Но зачем это нужно?

- Чисто в теории это большая независимость от фреймворков. Мы можем рендерить Vue в React даже по сути не прибегая к ухищрениям при этом используя возможности экосистемы React
- Например отрендлерить Vue приложение в приложение на основе ReactNative. Тут уже микрофронтенды не спасут как в случае с Web-платформой
- Ну и главная причина: потому что мы можем! Иногда весело поделать абсурдныек вещи, чтобы лучше познакомиться с технологиями поближе
-->

---
layout: cover
---

# Vue Renderer to React

<v-clicks>

- Создаем свою прослойку между VDOM Vue и VDOM React
- DOM -> `React.createElement`
- `mount` -> `React.render`

</v-clicks>

<!--
Но как нгам это реализовать?

- Для начала нам нужна будет прослойка между Vue и React
- Нам необходимо будет поменять API работы с DOM на работу с реакт-нодами
- И позволить React приложению отрендериться самому

!! Далее идем DEMO по работе с Vueact !!

https://github.com/Sdju/speech/tree/main/2024/2_holy-spring_vue-renderer/vue-to-react-demo
-->

---
layout: cover
---

# Проблемы

<v-clicks>

- В хуке `mounted` мы получим в `ref` наш элемент прослойки между React и Vue
- В момент хука `mounted` реальная DOM нода еще не создана
- Использовать ui библиотеки для Vue получится маловероятно

</v-clicks>

<!--
Звучит все это хорошо. Но с какими проблемами мы потенциально столкнемся?

- В хуке mounted во Vue мы будем получать не DOM элемент у template ref-ов, а элементы нашей прослойки те Vueact-ноды
- Так как и React и Vue работают в асинхронном режиме для создания нод, то когда вызывается mounted, то это сигнал что создана Vueact-дерево, реакт же создаст DOM дерево позже и это может ввести нас в заблуждение
- Ну и соответственно использовать уже существующие UI-библиотеки с таким подходом не выйдет
-->

---
layout: cover
---

# Как можно было бы решить?

<v-clicks>

- Создать накопительную прослойку
- Пошаманить с `SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED`
- Пошаманить с Vue VDOM

</v-clicks>

<!--
Как можно было бы решить данные проблемы:

- Мы бы могли попытаться создать накопительную прослойку между моментами, когда Vue начинает работать с DOM нодой и когда реакт ее создаст. После того как DOM дерево будет действительно создана, она применит накопленные изменения
- Далее можно было бы попытаться пошаманить с внутренней работой реакта и вью для синхронизации работы хуков между ними

Эти задачи достаточно сложны и нетривиальны. Поэтому если вам хочется попытаться свои силы: то вот вполне себе возможность
-->
